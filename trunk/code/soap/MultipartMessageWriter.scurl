||| Copyright (C) 1998-2009, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{define-class public open MultipartMessageWriter

  field public character-encoding:CharEncoding
  field private stream:ByteOutputStream
  field private _tos:#TextOutputStream
  field private _boundary:#String
  field private _boundary-bytes:#ByteArray
  field private _final-boundary-bytes:#ByteArray

  {constructor public {default
                          stream:ByteOutputStream,
                          character-encoding:CharEncoding = CharEncoding.utf8,
                          multipart-boundary:#String = null
                      }
    set self.stream = stream
    set self.character-encoding = character-encoding
    {if-non-null mb = multipart-boundary then
        set self._boundary = mb
    }
  }

  {getter public open {boundary}:String
    {if self._boundary == null then
        set self._boundary = {MultipartMessageWriter.random-multipart-boundary}
    }
    {return {non-null self._boundary}}
  }

  {getter private {boundary-bytes}:ByteArray
    {if self._boundary-bytes == null then
        set self._boundary-bytes =
            {encode-string {format "\r\n--%s\r\n", self.boundary}}} ||""
    {return {non-null self._boundary-bytes}}
  }

  {getter private {final-boundary-bytes}:ByteArray
    {if self._final-boundary-bytes == null then
        set self._final-boundary-bytes =
            {encode-string
                {format "\r\n--%s--", self.boundary}}} ||""
    {return {non-null self._final-boundary-bytes}}
  }

  {getter protected open {tos}:TextOutputStream
    {if self._tos == null then
        set self._tos = {TranscodingTextOutputStream
                            self.stream,
                            self.character-encoding,
                            false
                        }
    }
    {return {non-null self._tos}}
  }

  {method public open {write-message message:MultipartMessage}:void
    {for part in message do
        {self.write-part part}
    }
    {self.end-multipart-message}
  }

  {method public open {write-part part:MIMEPart}:void
    {self.insert-multipart-boundary}
    {self.write-headers part.headers}
    {self.write-body part.body asa ByteArray}
  }
  
  {method protected open {write-body body:ByteArray}:void
    {dump {self.stream.write body}}
  }

  {method protected open {write-headers headers:#MIMEHeaders}:void
    {if-non-null headers then
        {for v key k in headers do
            {self.write-header k, v}
        }
    }
    {self.end-line}
  }

  {method protected open {write-header key:String, val:String}:void
    let main-string:String = val
    let sub-string:String = ""

    def than:int = 80 - key.size - 2
    {if val.size > than then
        def idx = {val.find
                      ';',
                      search-direction = SearchDirection.backward,
                      starting-index = than
                  }

        def m-idx = {if idx != -1 then
                        idx
                     else
                        than
                    }
        set main-string = {val.substr 0, m-idx}
        set sub-string = "\t" & {val.tail m-idx + 1}
    }

    {self.tos.write-one-string
        {format "%s: %s", key, main-string}}
    {self.end-line}

    {if not sub-string.empty? then
        {while sub-string.size > 80 do
            def idx = {sub-string.find
                          ';',
                          search-direction = SearchDirection.backward,
                          starting-index = 80
                      }
            def m-idx = {if idx != -1 then
                            idx
                         else
                            80
                        }
            {self.tos.write-one-string {sub-string.substr 0, m-idx}}
            {self.end-line}

            set sub-string = "\t" & {sub-string.tail m-idx + 1}
        }
        {self.tos.write-one-string sub-string}
        {self.end-line}
    }
  }

  {method protected open {insert-multipart-boundary}:void
    {self.stream.write self.boundary-bytes}
  }

  {method protected open {end-multipart-message}:void
    {self.stream.write self.final-boundary-bytes}
  }

  {method protected open {end-line}:void
    {self.tos.write-one-string "\r\n"}
  }

  {define-proc package {random-multipart-boundary}:String
    let r:Random = {Random}
    {return
        {format "SEPARATOR%x-%x", ||""
            {r.next-non-negative-int32},
            {r.next-non-negative-int32}
        }
    }
  }
}
