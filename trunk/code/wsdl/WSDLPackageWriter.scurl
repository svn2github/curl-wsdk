||| Copyright (C) 1998-2009, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{define-class public open WSDLPackageDirectives
  field public source-url:Url
  field public target-url:#Url
  field public curl-versions:String
  field public curlify-names?:bool
  field public include-async-methods?:bool
  field public preserve-existing-files?:bool
  field public package-prefix:#String
  field public package-suffix:#String
  field public namespace-specs:WSDLNamespaceSpecs
  
  {constructor public {default
                          source-url:Url,
                          target-url:#Url = null,
                          curl-versions:String = {curl-versions-string},
                          curlify-names?:bool = true,
                          include-async-methods?:bool = true,                          
                          preserve-existing-files?:bool = false,
                          package-prefix:#String = "COM.CURL.WSDL.",
                          package-suffix:#String = null,
                          ...:WSDLNamespaceSpec             
                      }
    || HTTP locations are disallowed
    {ensure-local-filesystem source-url}
    {if-non-null target-url then
        {ensure-local-filesystem target-url}}
    
    set self.source-url = source-url
    set self.target-url = target-url
    set self.curl-versions = curl-versions
    
    set self.curlify-names? = curlify-names?
    set self.include-async-methods? = include-async-methods?
    set self.preserve-existing-files? = preserve-existing-files?
    set self.package-prefix = package-prefix
    set self.package-suffix = package-suffix
    
    def specs = {WSDLNamespaceSpecs}
    {for spec in ... do
        def uri = spec.uri
        set specs[uri] = spec
    }
    set self.namespace-specs = specs
  }
  {method public open {clone-for
                          source-url:Url,
                          target-url:#Url = self.target-url,
                          curl-versions:String = self.curl-versions,
                          curlify-names?:bool = self.curlify-names?,
                          include-async-methods?:bool = self.include-async-methods?,                          
                          preserve-existing-files?:bool = self.preserve-existing-files?,
                          package-prefix:#String = self.package-prefix,
                          package-suffix:#String = self.package-suffix,
                          ...:WSDLNamespaceSpec        
                      }:WSDLPackageDirectives
    {return
        {WSDLPackageDirectives source-url,
            target-url = target-url,
            curl-versions = curl-versions,
            curlify-names? = curlify-names?,
            include-async-methods? = include-async-methods?,                          
            preserve-existing-files? = preserve-existing-files?,
            package-prefix = package-prefix,
            package-suffix = package-suffix,
            {splice self.namespace-specs},
            {splice ...}
        }}
  }
}
{def public WSDLNamespaceSpecs =
    {HashTable-of String, WSDLNamespaceSpec}
}
{define-class public open WSDLNamespaceSpec
  field public-get constant uri:String
  field public-get constant short-name:String
  field public-get constant directory-suffix:String
  field public-get constant preserve-existing-files?:bool
  field public-get constant skip-processing?:bool

  {constructor public {default
                          uri:String,
                          short-name:String = {namespace-contraction uri},
                          directory-suffix:String = short-name,
                          preserve-existing-files?:bool = false,
                          skip-processing?:bool = false
                      }
    set self.uri = uri
    set self.short-name = short-name
    set self.directory-suffix = directory-suffix
    set self.preserve-existing-files? = preserve-existing-files?
    set self.skip-processing? =  skip-processing?
  }
}

{define-class public open WSDLPackageWriter
  field public-get constant wsdl:WSDL
  field public-get constant wsdl-writer:WSDLWriter
  field public-get constant schema:WSDLSchema
  field public-get constant directives:WSDLPackageDirectives

  {constructor public {default
                          directives:WSDLPackageDirectives
                      }
    set self.directives = directives
    set self.wsdl =
        {WSDL directives.source-url,
            curlify-names? = directives.curlify-names?}
    set self.schema = self.wsdl.schema
    set self.wsdl-writer =
        {WSDLWriter
            self.wsdl.schema,
            self.wsdl.services, 
            self.wsdl.curl-namer,
            self.wsdl.type-to-element-name,
            directives.source-url}
  }
  || code generation
  || --------------------
  {method public open {generate-code}:Url
    {return
        {if-non-null loc = self.directives.target-url then
            {if loc.extension == ".scurl" then
                || monolithic file
                {self.generate-code-file loc}
             else
                || specified directory
                {self.generate-code-directory loc}}
         else
            || derived directory
            def sloc = self.directives.source-url
            def name =
                {if sloc.extension.empty? then
                    || guard against lack of extension
                    sloc.basename & "-PACKAGE"
                 else sloc.basename}
            {self.generate-code-directory
                {sloc.merge name}}
        }}
  }
  {method public open {generate-code-file sloc:Url}:Url
    def package-name = self.service-package-name
    {with-open-streams out = {write-open sloc} do
        {self.write-consolidated-package-herald out,
            package-name}
        {self.dump-client-stubs out}}
    {return sloc}
  }
  {method public open {generate-code-directory
                          dir:Url,
                          include-test-applet?:bool = false
                      }:Url
    || prepare output directory
    {self.prepare-output-directory dir,
        preserve-existing-files? = self.directives.preserve-existing-files?}

    || obtain info
    def ns = self.defined-namespaces
    def service-class-names = self.service-class-names
    
    || generate service class(es)
    || --------------------
    def wlocs = {UrlArray}
    def all-types = {{Set-of WSDLSchemaType}}
    {for port key service-class-name in {self.wsdl-writer.service-classes} do
        def wfile = service-class-name & ".scurl"
        def wloc = {dir.concat wfile}
        {wlocs.append wloc}
        {with-open-streams
            out = {write-open wloc}
         do
            {self.write-preamble out}
            {self.wsdl-writer.dump-service-class
                out, service-class-name, port,
                do-async? = self.directives.include-async-methods?,
                all-types = all-types}
        }}
    
    || generate type definitions
    || --------------------
    || ordered types
    def types = {self.sorted-types all-types}
    || additional packages
    def all-packages = {{Set-of String}}
    {for type in types do
        {if-non-null package = type.package-name then
            {all-packages.insert package}}}
    || process types by namespace
    def plocs = {UrlArray}
    {for n in ns do
        || namespace contraction
        def spec = {self.namespace-spec-for n}
        def P = spec.short-name
        def D = spec.directory-suffix
        || corresponding directory
        def pdir = {dir.concat D}
        {self.prepare-output-directory pdir,
            preserve-existing-files? = D.empty? or spec.preserve-existing-files?}
        def ploc = {pdir.concat "load.scurl"}
        {plocs.append ploc}
        || collect additional imports
        def needed-packages = {{Set-of String}}
        
        || generate namespace includes
        || --------------------
        {with-open-streams
            out = {write-open ploc}
         do
            {self.write-preamble out}
            || NOTE: package declaration not enabled
            {format out = out,
                |"||| Generated for namespace: '%s'"| & "\n\n" &
                |"|IGNORE# "| & "\n" &
                |"{curl 7.0 package}"| & "\n" &
                |"{package %s,"| & "\n" &
                |"    {compiler-directives careful? = true}}"| & "\n" &
                |"{import * from COM.CURL.WSDK.SOAP}"| & "\n" &
                |"#IGNORE|"| & "\n\n",
                n, P}
            || imported namespaces
            def imports = {StringArray}
            {for pair in self.schema.namespace-imports do
                {if pair.t0 == n then
                    def import = pair.t1
                    {if {imports.find import} < 0 then
                        {imports.append import}}
                }}
            {imports.sort}
            {for import in imports do
                def spec = {self.namespace-spec-for import}
                def P = spec.short-name
                {format out = out,
                    |"|| namespace: '%s'"| & "\n" &
                    |"|IGNORE#{import * from %s}#IGNORE|"| & "\n",
                    import, P}}
            {format out = out, "\n"}            
            || process by type
            {for t in types do
                || skip other namespaces
                def tns =
                    {if-non-null n = t.xml-name
                     then n.namespace
                     else null}
                {if tns != n then
                    {continue}}
                || skip unnamed types
                {if t isa WSDLSchemaArrayType or
                    || TODO: remove when union loses superfluous alias
                    t isa WSDLSchemaUnionType
                 then
                    {continue}}            
                || note additional imports
                {if-non-null package = t.package-name then
                    {needed-packages.insert package}}
                || include source file
                def file = t.ref-name & ".scurl"
                def sloc = {pdir.concat file}
                {format out = out,
                    |"{include "%s"}"|,
                    file}
                {format out = out, "\n"}

                || generate source file
                || --------------------
                {with-open-streams out = {write-open sloc} do
                    {self.write-preamble out}
                    {t.dump out}}
            }
            || code additional imports
            def sorted-packages = {StringArray}
            {for package in needed-packages do
                {sorted-packages.append package}}
            {sorted-packages.sort}
            {if not sorted-packages.empty? then
                {out.write-one '\n'}
                {for package in sorted-packages do
                    {format out = out,
                        |"{import * from %s}"|, package}
                    {out.write-one '\n'}}
                {out.write-one '\n'}}
            || imports here need not be in container
            {all-packages.difference needed-packages}
        }
    }
    def package-name = self.service-package-name
  
    || generate package
    || --------------------
    def ploc = {dir.concat "load.scurl"}
    {with-open-streams out = {write-open ploc} do
        def locs = {wlocs.clone}
        {locs.concat plocs}
        {self.write-service-package out,
            package-name,
            dir,
            locs}
        || additional imports
        def sorted-packages = {StringArray}
        {for package in all-packages do
            {sorted-packages.append package}}
        {sorted-packages.sort}
        {if not sorted-packages.empty? then
            {out.write-one '\n'}
            {for package in sorted-packages do
                {format out = out,
                    |"{import * from %s}"|, package}
                {out.write-one '\n'}}
            {out.write-one '\n'}}
    }
    || generate manifest
    || --------------------
    {with-open-streams out = {write-open {dir.concat "service-manifest.mcurl"}} do
        {self.write-service-manifest out,
            package-name}
    }
    {if include-test-applet? then
        || generate test manifest
        || --------------------
        {with-open-streams out = {write-open {dir.concat "manifest.mcurl"}} do
            {self.write-test-manifest out,
                package-name}
        }
        || generate test applet
        || --------------------
        {with-open-streams out = {write-open {dir.concat "_test.curl"}} do
            {self.write-test-applet out,
                package-name,
                service-class-names}
        }
    }
    {return ploc}
  }
  || WSDK 1.1 compatibility
  || --------------------
  {method public open {dump-client-stubs out:TextOutputStream}:void
    || service classes and support types
    {self.wsdl-writer.dump-client-stubs out, 
        do-async? = self.directives.include-async-methods?}
  }
  || writer methods
  || --------------------
  {method package {write-service-package
                      out:TextOutputStream,
                      package-name:String,
                      dir:Url,
                      include-locs:UrlArray
                  }:void
    {self.write-preamble out}
    {format out = out,
        |"{curl 7.0 package}"| & "\n" &
        |"{package %s,"| & "\n" &
        |"    {compiler-directives careful? = true}}"| & "\n" &
        |"{import * from COM.CURL.WSDK.SOAP}"| & "\n",
        package-name
    }
    {for loc in include-locs do
        {format out = out,
            |"{include "%s"}"|,
            {loc.name-relative-to-url dir}}
        {format out = out, "\n"}
    }
  }
  {method package {write-service-manifest
                      out:TextOutputStream,
                      package-name:String
                  }:void
        {self.write-preamble out}
        {format out = out,
            |"{curl 7.0 manifest}"| & "\n" &
            |"{delegate-to COM.CURL.WSDK}"| & "\n"
        }
        {do
            {format out = out,
                |"{component package %s,"| & "\n" &
                |"    location = "%s"}"|,
                package-name,
                "load.scurl"}
            {format out = out, "\n"}
        }
  }
  {method package {write-test-manifest
                      out:TextOutputStream,
                      package-name:String
                  }:void
        {self.write-preamble out}
        {format out = out,
            |"{curl 7.0 manifest}"| & "\n" &
            |"{manifest %s}"| & "\n" &
            || ### HARDWIRED FOR TESTING
            |"{component manifest COM.CURL.WSDK, location = "../../../../code/manifest.mcurl"}"| & "\n" &
||--            |"{delegate-to COM.CURL.WSDK.WORK, location = "../../../manifest.mcurl"}"| & "\n" &
            |"{include "service-manifest.mcurl"}"| & "\n",
            package-name
        }
  }
  {method package {write-test-applet
                      out:TextOutputStream,
                      package-name:String,
                      service-class-names:StringArray
                  }:void
        {self.write-preamble out}
        {format out = out,
            |"{curl 7.0 applet}"| & "\n" &
            |"{applet manifest = "manifest.mcurl"}"| & "\n" &
            |"{import * from COM.CURL.WSDK.SOAP}"| & "\n" &
            |"{import * from %s}"| & "\n",
            package-name
        }
        {for service-class in service-class-names do
            {format out = out,
                |"{value"| & "\n" &
                |"    def service = {%s}"| & "\n\n" &
                |"    || TODO: call service methods ..."| & "\n\n" &
                |"    service"| & "\n" &
                |"}"| & "\n",
                service-class}
        }

  }
  {method package {write-preamble
                      out:TextOutputStream
                  }:void
    def source-url = self.directives.source-url
    {format out = out,
        |"|| This file was generated with COM.CURL.WSDK.WSDL"| & "\n" &
        |"||  for WSDL file: %s"| & "\n\n",
        {type-switch source-url.stem
         case s:StringDirectory do "unknown"
         else source-url.name}}
  }
  {method package {write-consolidated-package-herald
                      out:TextOutputStream,
                      package-name:String
                  }:void
    || package herald template
    let constant package-herald-template:String = 
        {format 
            "\{curl %s package\}\n\{package %%s,\n"
            & "    \{compiler-directives careful? = true\},\n"
            & "    wsdl = \"%%s\"\}\n\n",
            self.directives.curl-versions}
   {format out = out, 
        package-herald-template,
        package-name,
        self.directives.source-url}
  }
  || helper methods
  || --------------------
  field package _service-class-names:#StringArray
  {getter public open {service-class-names}:StringArray
    {if self._service-class-names == null then
        def service-class-names = {StringArray}
        {for key service-class-name in {self.wsdl-writer.service-classes} do
            {service-class-names.append service-class-name}}
        {service-class-names.sort}
        set self._service-class-names = service-class-names}
    {return {non-null self._service-class-names}}
  }
  field package _defined-namespaces:#StringArray
  {getter public open {defined-namespaces}:StringArray
    {if self._defined-namespaces == null then
        def ns = {StringArray}
        {for namespace in self.schema.local-namespaces do
            def n = namespace
            {if {ns.find n} < 0 then
                {ns.append n}}}
        {ns.sort}
        set self._defined-namespaces = ns}
    {return {non-null self._defined-namespaces}}
  }
  {getter public open {service-package-name}:String
    def package-prefix = 
        {if-non-null package-prefix = self.directives.package-prefix
         then package-prefix
         else self.package-prefix-default}
    def package-suffix =
        {if-non-null package-suffix = self.directives.package-suffix
         then package-suffix
         else self.package-suffix-default}
    def package-name =
        {if package-prefix.empty? and package-suffix.empty? then
            self.service-name-default
         elseif package-prefix.empty? then package-suffix
         elseif package-suffix.empty? then package-prefix
         else package-prefix & "." & package-suffix}
    {return package-name}
  }
  {getter public open {package-prefix-default}:String
    {return        
        {if-non-null tns = self.wsdl.target-namespace
         then {namespace-contraction tns}
         else ""}}
  }
  {getter public open {package-suffix-default}:String
    {return self.service-name-default}
  }
  {getter public open {service-name-default}:String
    {return self.directives.source-url.basename}
  }
  {method package {namespace-spec-for
                      namespace:String
                  }:WSDLNamespaceSpec
    def specs = self.directives.namespace-specs
    {if not {specs.key-exists? namespace} then
        set specs[namespace] =
            {WSDLNamespaceSpec namespace}}
    def spec = specs[namespace]
    {return spec}
  }   
  {method public open {sorted-types
                          types:{Set-of WSDLSchemaType}
                      }:{Array-of WSDLSchemaType}
    def sorted-types = {{Array-of WSDLSchemaType}}
    {for type in types do
        {sorted-types.append type}}
    {sorted-types.sort comparison-proc =
        {fn x, y =>
            {x.ref-name.compare y.ref-name} <= 0}
    }
    {return sorted-types}
  }
  {method package {prepare-output-directory
                      dir:Url,
                      preserve-existing-files?:bool = false
                  }:void
    def clear-existing-files? = not preserve-existing-files?
    {if clear-existing-files? and
        {local-directory-exists? dir} 
     then
        {delete dir, recurse? = true}}
    {create-Directory dir,
        create-missing-parents? = true,
        error-if-exists? = clear-existing-files?}
  }
  || NOTE: not used
||--  {method package {all-types
||--                  }:{Array-of WSDLSchemaType}
||--    def types = {{Array-of WSDLSchemaType}}
||--    {for x key k in self.schema.names do
||--        {type-switch x
||--         case t:WSDLSchemaType do
||--            def ns = k.namespace
||--            {if || user defined type
||--                not {WSDLSchema.known-namespaces.member? ns}
||--                || NOTE: this assumes known-namespaces need no type definitions
||--                || TODO: make this explicit
||--             then
||--                {types.append t}}}}
||--    {types.sort comparison-proc =
||--        {fn x, y =>
||--            {x.ref-name.compare y.ref-name} <= 0}
||--    }
||--    {return types}
||--  }
}
|| helper procs
|| --------------------
{define-proc package {curl-versions-string
                         package:Package = {get-current-package}
                     }:String
    || determine applicable curl-versions
    def curl-versions = 
        {if-non-null vs = package.meta-data.curl-versions then
            || should be declared in package herald
            let buf:StringBuf = {StringBuf}
            {for v in vs do
                {if not buf.empty? then
                    {buf.concat ", "}}
                {buf.concat {String v}}}
            {buf.to-String}
         else
            || fallback to latest version
            {String {curl-version-number.n-clone n = 2}}}
    {return curl-versions}
}
|| derives Curl package identifier from XML namespace
{define-proc package {namespace-contraction ns:String}:String
    {if ns.empty? then
        {return "_"}}
    || ignore the scheme
    def ps = {StringArray "http://", "https://", "urn:"}
    {for p in ps do
        {if {ns.prefix? p} then
            def i = p.size
            set ns = {ns.tail i}
            {break}}}
    || get directory components
    def xs = {ns.split split-chars = "/:"}
    {xs.filter {fn x => x.size > 0}}
    || get host components
    def hs = {xs[0].split split-chars = "."}
    || build up name
    def name = {StringBuf efficient-size = ns.size}
    def name-append =
        {proc {parts:StringArray}:void
            {for part in parts do
                {unless name.empty? do
                    {name.append '.'}}
                || NOTE: guard against illegal start character
                || TODO: use CurlNamer
                {unless Identifier.start-chars[part[0]] do
                    {name.append '_'}}
                {name.concat part}}}
    || starting with reversed host components
    {hs.reverse}
    {name-append hs}
    || followed by remaining directory components
    {xs.remove 0}
    {name-append xs}
    || as uppercase string
    {name.to-upper}
    {return {name.to-String}}                     
}
{define-proc package {ensure-local-filesystem loc:Url}:void
    {if loc.stem isa StringDirectory then
        {return}}
    {if not {in-local-filesystem? loc} then
        {error {lmessage Not in local filesystem: {value loc}}}}
}
|| directives writer
|| --------------------
{define-class public open WSDLPackageDirectivesWriter
  field public-get out:TextOutputStream
  {constructor public {default  out:TextOutputStream = {get-stdout}}
    set self.out = out
  }
  {method public open {write-object obj:Object}:void
    {type-switch obj
     case obj:WSDLPackageDirectives do
        {self.write-directives obj}
     case obj:WSDLNamespaceSpec do
        {self.write-namespace-spec obj}
     else
        {error {lmessage WSDLPackageDirectivesWriter: unexpected type '{value obj}'}}}
  }
  {method package {write-directives obj:WSDLPackageDirectives}:void
    || TODO: suppress defaulted values
    {self.fmt |"
{WSDLPackageDirectives
    %s,
    target-url = %s,
    curl-versions = %s,
    curlify-names? = %s,
    include-async-methods? = %s,                          
    preserve-existing-files? = %s,
    package-prefix = %s,
    package-suffix = %s       
"|,
        {self.val obj.source-url},
        {self.val obj.target-url},
        {self.val obj.curl-versions},
        {self.val obj.curlify-names?},
        {self.val obj.include-async-methods?},
        {self.val obj.preserve-existing-files?},
        {self.val obj.package-prefix},
        {self.val obj.package-suffix}
    }
    {for spec in obj.namespace-specs do
        {format out = self.out, ",\n"}
        {self.write-namespace-spec spec}
    }
    {self.fmt "\n\}\n"}
  }
  {method package {write-namespace-spec obj:WSDLNamespaceSpec}:void
    {self.fmt |"
{WSDLNamespaceSpec
    %s,
    short-name = %s,                          
    directory-suffix = %s,
    preserve-existing-files? = %s,
    skip-processing? = %s      
}  
"|,
        {self.val obj.uri},
        {self.val obj.short-name},
        {self.val obj.directory-suffix},
        {self.val obj.preserve-existing-files?},
        {self.val obj.skip-processing?}
    }
  }
  {method package {val x:any}:String
    {return
        {type-switch x
         case x:Null do "null"
         case x:bool do {String x}
         case x:Url do {format |"{url "%s"}"|, x.name}
         case x:String do {format |""%s""|, x}
         else {String x}
        }}
  }
  {method package {fmt out:TextOutputStream = self.out, ...}:void
    {format out = out, {splice ...}}
  }
}