||| Copyright (C) 1998-2009, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{define-class public open WSDLWriter
  field public-get constant schema:WSDLSchema
  field public-get constant services:{Array-of WSDLService}
  field public-get constant curl-namer:WSDLCurlNamer
  field public-get constant type-to-element-name:{HashTable-of XMLName, XMLName}
  field public-get constant source-url:Url

  {constructor public {default
                          schema:WSDLSchema,
                          services:{Array-of WSDLService},
                          curl-namer:WSDLCurlNamer,
                          type-to-element-name:{HashTable-of XMLName, XMLName},
                          source-url:Url
                      }
    set self.services = services
    set self.schema = schema
    set self.curl-namer = curl-namer
    set self.type-to-element-name = type-to-element-name
    set self.source-url = source-url
  }
  
  || WSDK 1.1 API
  || --------------------
  {method public open {dump-client-stubs
                          out:TextOutputStream,
                          exclude-unreferenced-types?:bool = false,
                          do-async?:bool = false
                      }:StringArray
    || service class(es}
    def (stub-classes, all-types) =
        {self.dump-service-classes out,
            exclude-unreferenced-types? = exclude-unreferenced-types?,
            do-async? = do-async?}
    || types
    {self.dump-types out, all-types}
    {return stub-classes}
  }
  
  ||implementation
  || --------------------
  {method public open {dump-service-classes 
                          out:TextOutputStream,
                          exclude-unreferenced-types?:bool = false,
                          do-async?:bool = false
                      }:(StringArray, {Set-of WSDLSchemaType})

    || %%% PREAMBLE
    || ~~~~~~~~~~~~~~~~~~~~
    {out.write-one-string "\|\| This file was generated with COM.CURL.WSDK.WSDL\n"}
    {format out = out, "\|\| WSDL file: %s\n\n",
        {type-switch self.source-url.stem
         case s:StringDirectory do "unknown"
         else self.source-url.name}}
    {out.write-one-string
        "\{import * from COM.CURL.WSDK.SOAP\}\n"
    }

    || collect defined types
    let stub-classes:StringArray = {StringArray}
    let all-types:{Set-of WSDLSchemaType} = {new {Set-of WSDLSchemaType}}

    {for port key service-class-name in {self.service-classes} do
        {stub-classes.append service-class-name}
        {self.dump-service-class out,
            service-class-name,
            port,
            do-async? = do-async?,
            all-types = all-types,
            exclude-unreferenced-types? = exclude-unreferenced-types?
        }
    }
    {return stub-classes, all-types}
  }
  
  {method public open {service-classes
                      }:{HashTable-of String, WSDLServicePort}
    def service-classes = {{HashTable-of String, WSDLServicePort}}
    {for service in self.services do
        
        || generate distinct class for each port
        || -- they may have clashing method names
        || -- they may (should) have different url
        || -- this allows runtime relocation
        
        || collect soap ports
        def soap-ports =
            {service.ports.filter-clone
                {fn port =>
                    port.extensions.size > 0 and
                    port.extensions[0] isa WSDLSOAPAddress}}
        
        || process soap ports
        {for port in soap-ports do            
            
            || FIXME type would vary by binding...
            || FIXME should the service name have a namespace?
            
            || normal case is just one: use service name
            || exceptional case is more than one: use port names
            def name = 
                {if soap-ports.size == 1 then
                    service.name
                 else
                    port.name
                }
            def soap-url-string =
                {type-switch port.extensions[0] 
                 case a:WSDLSOAPAddress do
                    a.location
                 else
                    {continue}
                }
            def service-class-name =
                {self.curl-namer.get-curl-name
                    {XMLName.unchecked "", name},
                    curl-type = "class"
                }
            set service-classes[service-class-name] = port
        }
    }
    {return service-classes}
  }
  
  {method public open {dump-service-class
                          out:TextOutputStream,
                          service-class-name:String,
                          port:WSDLServicePort,
                          do-async?:bool = false,
                          exclude-unreferenced-types?:bool = false,
                          all-types:{Set-of WSDLSchemaType} =
                              {{Set-of WSDLSchemaType}}
                      }:{Set-of WSDLSchemaType}
    
    || pre-reserve names that are already used
    {self.curl-namer.get-curl-name
        {new XMLName, "", "register-types"},
        scope = service-class-name & '.',
        curl-type = "method"
    }
    {self.curl-namer.get-curl-name
        {new XMLName, "", "soap-caller"},
        scope = service-class-name & '.',
        curl-type = "field"
    }
    || add documentation
    {if-non-null service = port.service then
        {self.format-documentation out, service}}

    || types of elements of document-style message parts should never be generated
    let ignore-types:{Set-of WSDLSchemaType} = {new {Set-of WSDLSchemaType}}
    let note-ignore-type:{proc-type {WSDLMessage}:void} =
        {proc {m:WSDLMessage}:void
            {for p in m.parts do
                {if-non-null e = p.element then
                    {if-non-null t = e._type then
                        {ignore-types.insert t}}}
            }}
    
    {format
        out = out,
        "\{define-class public %s \{inherits WSDLHTTPRPCPostClient\}\n",
        service-class-name
    }
    let constant types:{HashTable-of WSDLSchemaType, #XMLName} =
        {new {HashTable-of WSDLSchemaType, #XMLName}}
    
    || %%% OPERATIONS LOOP
    || ~~~~~~~~~~~~~~~~~~~~
    def binding = port.binding
    def port-type = binding.type
    def method-names = {StringArray}
    {for binding-op in binding.operations do
        let port-op:WSDLPortOperation =
            {if-non-null po = {port-type.find-port-operation binding-op}
             then
                po
             else
                {wsdl-exception node = binding-op.node,
                    {hlmessage
                        No portType found for operation 
                        '{WSDL.format-name name = binding-op.name, binding-op.node}'.,
                    }
                }
            }
        || skip bindings with nothing good in them.
        {if binding-op.extensions.size <= 0 then
            {continue}
        }
        let constant soap-op:WSDLSOAPOperation =
            {type-switch binding-op.extensions[0]
             case so:WSDLSOAPOperation do
                so
             else
                {continue}
            }

        let input-soap-body:#WSDLSOAPBody = null
        let constant input-soap-headers:{Array-of WSDLSOAPHeader} =
            {new {Array-of WSDLSOAPHeader}}
        def m-in = 
            {if-non-null input = port-op.input then
                input.message
             else
                null
            }
        {if-non-null m-in then
            {if soap-op.style == WSDLSOAPStyle.document then
                {note-ignore-type m-in}}

            {for e in binding-op.input.extensions do
                {type-switch e
                 case sb:WSDLSOAPBody do
                    set input-soap-body = sb
                 case sh:WSDLSOAPHeader do
                    {input-soap-headers.append sh}
                }
            }
        }
        let output-soap-body:#WSDLSOAPBody = null
        let constant output-soap-headers:{Array-of WSDLSOAPHeader} =
            {new {Array-of WSDLSOAPHeader}}
        {if-non-null bo-output = binding-op.output then
            {for e in bo-output.extensions do
                {type-switch e
                 case sb:WSDLSOAPBody do
                    set output-soap-body = sb
                 case sh:WSDLSOAPHeader do
                    {output-soap-headers.append sh}
                }
            }
        }
        {if input-soap-body != null and output-soap-body != null then
            {if input-soap-body.encoding-style != null and
                output-soap-body.encoding-style != null and
                input-soap-body.encoding-style !=
                output-soap-body.encoding-style
             then
                {wsdl-exception node = output-soap-body.node,
                    {hlmessage Can not handle mis-matching encodings.}}
            }
        }
        let soap-body-input-namespace:String =
            {if input-soap-body != null and
                input-soap-body.namespace != null
             then
                {non-null input-soap-body.namespace}
             else
                ""
            }
        let soap-body-output-namespace:String =
            {if output-soap-body != null and
                output-soap-body.namespace != null
             then
                {non-null output-soap-body.namespace}
             else
                ""
            }
        let soap-body-encoding:#String =
            {if output-soap-body != null and
                output-soap-body.encoding-style != null
             then
                {non-null output-soap-body.encoding-style}
             elseif input-soap-body != null and
                input-soap-body.encoding-style != null
             then
                {non-null input-soap-body.encoding-style}
             else
                null
            }
        let constant operation-input-xml-name:XMLName =
            {new XMLName, soap-body-input-namespace, binding-op.name}
        let constant operation-output-xml-name:XMLName =
            {new XMLName, soap-body-output-namespace, binding-op.name}
        let (in-params:WSDLParamArray, request-operation:#XMLName) =
            {if-non-null m-in then
                {m-in.parts-as-params
                    soap-op.style,
                    operation-input-xml-name,
                    parts = input-soap-body.parts
                }
             else
                ({WSDLParamArray}, null)
            }
        let param-type-signature:StringBuf = {new StringBuf}
        {for param in in-params do 
            {param-type-signature.concat param.type.ref-name}
            {param-type-signature.concat ", "}
        }
        let (out-params:WSDLParamArray, response-operation:#XMLName) =
            {if-non-null po-output = port-op.output then
                let m-out:WSDLMessage = po-output.message
                {if soap-op.style == WSDLSOAPStyle.document then
                    {note-ignore-type m-out}}
                {m-out.parts-as-params
                    soap-op.style,
                    operation-output-xml-name,
                    parts = output-soap-body.parts,
                    || for looser nullability 
                    for-response? = true
                }
             else
                ({WSDLParamArray}, null)
            }
        || make headers' parameters
        let constant input-header-required-params:WSDLParamArray =
            {new WSDLParamArray}
        let constant input-header-not-required-params:WSDLParamArray =
            {new WSDLParamArray}
        {for h in input-soap-headers do
            {h.append-header-as-params
                {if h.required? then
                    input-header-required-params
                 else
                    input-header-not-required-params
                },
                operation-input-xml-name,
                m-in.name
            }
        }
        let constant output-header-required-params:WSDLParamArray =
            {new WSDLParamArray}
        let constant output-header-not-required-params:WSDLParamArray =
            {new WSDLParamArray}
        {if-non-null po-output = port-op.output then
            let m-out:WSDLMessage = po-output.message
            {for h in output-soap-headers do
                {h.append-header-as-params
                    {if h.required? then
                        output-header-required-params
                     else
                        output-header-not-required-params
                    },
                    operation-output-xml-name,
                    m-out.name
                }
            }
        }

        let constant documentation-things:{Array-of #WSDLDocumentedNode} =
            {new {Array-of #WSDLDocumentedNode},
                port-op,
                port-op.input,
                m-in,
                binding-op
            }
        {if-non-null po-output = port-op.output then
            {documentation-things.append po-output}
            {documentation-things.append po-output.message}
        }
        {if-non-null faults = port-op.faults then
            {for f in faults do
                {documentation-things.append f}
                {documentation-things.append f.message}
            }
        }

        || %%% METHOD LOOP
        || ~~~~~~~~~~~~~~~~~~~~
        def name =
            {self.curl-namer.get-curl-name port-op.name,
                scope = service-class-name & '.',
                curl-type = "method",
                curl-aux-name-info = {param-type-signature.to-String}
            }
        || write method twice, sync and async,
        || using common operation definitions
        {for method-pass:int = 0 to 2 do

            def sync-pass? = method-pass == 0
            def async-pass? = method-pass == 1
            def def-pass? = method-pass == 2

            {if async-pass? and not do-async? then
                {continue}
            }

            {out.write-one '\n'}
            
            || first the documentation
            {self.format-documentation out,
                {splice documentation-things}
            }
            || %%% METHOD NAME
            || ~~~~~~~~~~~~~~~~~~~~
            || FIXME: shouldn't method name have a namespace?
            {format out = out,
                "  \{method public \{%s",
                {if async-pass? then 
                    "async-" & name
                 elseif def-pass? then
                    {method-names.append name}
                    "define-" & name
                 else
                    name
                }
            }
            || %%% METHOD ARGUMENTS
            || ~~~~~~~~~~~~~~~~~~~~
            {if not def-pass? then
                let first-in-param?:bool = true
                {for param in in-params do
                    {if not first-in-param? then
                        {out.write-one ','}
                     else
                        set first-in-param? = false
                    }
                    {format out = out, " %s:%s%s",
                        param.curl-name,
                        {if param.nullable? then
                            "#"
                         else
                            ""
                        },
                        param.type.ref-name
                    }
                }
                || now add the header parameters to the argument list
                {for param in input-header-required-params do
                    {if not first-in-param? then
                        {out.write-one ','}
                     else
                        set first-in-param? = false
                    }
                    {format out = out, " %s:%s%s",
                        param.curl-name,
                        {if param.nullable? then
                            "#"
                         else
                            ""
                        },
                        param.type.ref-name
                    }
                }
                {for param in input-header-not-required-params do
                    {if not first-in-param? then
                        {out.write-one ','}
                     else
                        set first-in-param? = false
                    }
                    let constant ref-name:String = param.type.ref-name
                    {format out = out, " %s:%s%s = %s",
                        param.curl-name,
                        {if param.nullable? then
                            "#"
                         else
                            ""
                        },
                        ref-name,
                        {if param.nullable? then
                            "null"
                         elseif ref-name == "String" then
                            |""""|
                         else
                            {format
                                "\{uninitialized-value-for-type %s\}",
                                ref-name
                            }
                        }
                    }
                }
                {if async-pass? then
                    {if not first-in-param? then
                        {out.write-one ','}
                    }
                    {out.write-one-string
                        " event-handler:EventHandler, ...:EventHandler"
                    }
                }
            }
            {format out = out, "\}:"}
            || %%% METHOD RETURN TYPE
            || ~~~~~~~~~~~~~~~~~~~~
            {if async-pass? then
                {out.write-one-string "SOAPHTTPRPCPostAsyncWorker"}
             elseif def-pass? then
                {out.write-one-string "void"}
             else
                {if out-params.size + output-header-required-params.size +
                    output-header-not-required-params.size 
                    == 0
                 then
                    {out.write-one-string "void"}
                 else
                    {out.write-one '\('}
                    {for param key i in out-params do
                        {if i > 0 then
                            {out.write-one-string ", "}
                        }
                        {format out = out, "%s:%s%s",
                            param.curl-name,
                            {if param.nullable? then
                                "#"
                             else
                                ""
                            },
                            param.type.ref-name
                        }
                    }
                    {for param key i in output-header-required-params do
                        {if out-params.size + i > 0 then
                            {out.write-one-string ", "}
                        }
                        {format out = out, "%s:%s%s",
                            param.curl-name,
                            {if param.nullable? then
                                "#"
                             else
                                ""
                            },
                            param.type.ref-name
                        }
                    }
                    {if output-header-required-params.size + 
                        output-header-not-required-params.size > 0
                     then
                        {if out-params.size +
                            output-header-required-params.size > 0
                         then
                            {out.write-one-string ", "}
                        }
                        {out.write-one-string
                            "headers:#\{Array-of any\}, " &
                            "header-roles:#\{Array-of #String\}, " &
                            "header-must-understands:#\{Array-of bool\}"
                        }
                    }
                    {out.write-one '\)'}
                }
            }
            {out.write-one '\n'}
            || %%% METHOD BODY DEFS
            || ~~~~~~~~~~~~~~~~~~~~
            {if not def-pass? then
                {if input-header-required-params.size > 0 or
                    input-header-not-required-params.size > 0
                 then
                    {out.write-one-string
                        "    let constant request-header-names:\{Array-of #XMLName\} =\n" &
                        "        \{\{Array-of #XMLName\}"
                    }
                    {for param key i in input-header-required-params do
                        {if i > 0 then
                            {out.write-one ','}
                        }
                        {out.write-one '\n'}
                        {format out = out, "            %s",
                            {WSDLSchemaType.xml-name-to-curl-code param.xml-name}
                        }
                    }
                    {if input-header-required-params.size > 0 then
                        {out.write-one-string "\n        "}
                    }
                    {out.write-one-string
                        "\}\n" &
                        "    let constant request-header-types:\{Array-of SOAPObjectType\} =\n" &
                        "        \{\{Array-of SOAPObjectType\}"
                    }
                    || write out request header types
                    {for param key i in input-header-required-params do
                        {if i > 0 then
                            {out.write-one ','}
                        }
                        {out.write-one '\n'}
                        {out.write-one-string
                            {param.type.soap-object-type-string tab-level = 12}
                        }
                    }
                    {if input-header-required-params.size > 0 then
                        {out.write-one-string "\n        "}
                    }
                    {out.write-one-string
                        "\}\n" &
                        "    let constant request-headers:\{Array-of any\} =\n" &
                        "        \{\{Array-of any\}"
                    }
                    {for param key i in input-header-required-params do
                        {if i > 0 then
                            {out.write-one ','}
                        }
                        {out.write-one '\n'}
                        {format out = out,
                            "            %s",
                            param.curl-name
                        }
                    }
                    {if input-header-required-params.size > 0 then
                        {out.write-one-string "\n        "}
                    }
                    {out.write-one-string
                        "\}\n"
                    }
                    || now add any not-required headers that were actually
                    || supplied.
                    {for param key i in input-header-not-required-params do
                        {format out = out,
                            "    \{if \{keyword-supplied? %s\} then\n" &
                            "        \{request-header-types.append\n" &
                            "%s\n" &
                            "        \}\n" &
                            "        \{request-header-names.append\n" &
                            "           %s\n" &
                            "        \}\n" &
                            "        \{request-headers.append %s\}\n" &
                            "    \}\n",
                            param.curl-name,
                            {param.type.soap-object-type-string tab-level = 12},
                            {WSDLSchemaType.xml-name-to-curl-code param.xml-name},
                            param.curl-name
                        }
                    }
                }
            }
            || %%% METHOD BODY CALL
            || ~~~~~~~~~~~~~~~~~~~~
            || FIXME: Only do the body when doing the non-abstract pass
            || save any weird types to be initialized, add that to "default"
            || write out self.soaphttp.call with appropriate type information and
            || array with parameters in it, and using reader/write made in default

            {if async-pass? then
                {out.write-one-string
                    "    \{return\n" &
                    "        \{self.async-call\n"
                }
             elseif def-pass? then
                {out.write-one-string
                    "    set self.operations[\"" & name & "\"] = \n" &
                    "        \{Arguments\n"
                }
             else
                {out.write-one-string
                    "    let constant (responses:\{Array-of any\},\n" &
                    "         headers:#\{Array-of any\},\n" &
                    "         header-roles:#\{Array-of #String\},\n" &
                    "         header-must-understands:#\{Array-of bool\},\n" &
                    "         root-attributes:#\{Array-of XMLAttribute\}) =\n" &
                    "        \{self.call\n"
                }
            }
            || %%% METHOD BODY CALL INPUT ARGS
            || ~~~~~~~~~~~~~~~~~~~~
            {if not def-pass? then
                {out.write-one-string
||--                    "            self.service-location,\n" &
                    "            \"" & name & "\",\n" &
                    "            \{\{Array-of any\}"
                }
                || write out argument values
                {for param key i in in-params do
                    {if i > 0 then
                        {out.write-one ','}
                    }
                    {out.write-one-string "\n"}
                    || need to uniqify and clean names
                    {format out = out, "                %s",
                        param.curl-name
                    }
                }
                {out.write-one-string
                    "\n" &
                    "            \},\n"
                }
            }
            || %%% METHOD BODY CALL SPEC ARGS
            || ~~~~~~~~~~~~~~~~~~~~
            {if not def-pass? then
                || header input args
                {if input-header-required-params.size > 0 or
                    input-header-not-required-params.size > 0
                 then
                    {out.write-one-string
                        "            request-header-names = request-header-names,\n" &
                        "            request-header-types = request-header-types,\n" &
                        "            request-headers = request-headers,\n"
                    }
                }
                {if output-header-required-params.size > 0 or
                    output-header-not-required-params.size > 0
                 then
                    {out.write-one-string
                        "            response-header-names =\n" &
                        "                \{\{Array-of #XMLName\}\n"
                    }
                    {for param key i in output-header-required-params do
                        {format out = out, "                    %s",
                            {WSDLSchemaType.xml-name-to-curl-code param.xml-name}
                        }
                        {if i < ((output-header-required-params.size +
                                  output-header-not-required-params.size) - 1)
                         then
                            {out.write-one ','}
                        }
                        {out.write-one '\n'}
                    }
                    {for param key i in output-header-not-required-params do
                        {format out = out, "                    %s",
                            {WSDLSchemaType.xml-name-to-curl-code param.xml-name}
                        }
                        {if i < (output-header-not-required-params.size - 1) then
                            {out.write-one ','}
                        }
                        {out.write-one '\n'}
                    }
                    {out.write-one-string
                        "                \},\n" &
                        "            response-header-types =\n" &
                        "                \{\{Array-of SOAPObjectType\}\n"
                    }
                    || write out response header types
                    {for param key i in output-header-required-params do
                        {out.write-one-string
                            {param.type.soap-object-type-string tab-level = 20}
                        }
                        {if i < ((output-header-required-params.size +
                                  output-header-not-required-params.size) - 1)
                         then
                            {out.write-one ','}
                        }
                        {out.write-one '\n'}
                    }
                    {for param key i in output-header-not-required-params do
                        {out.write-one-string
                            {param.type.soap-object-type-string tab-level = 20}
                        }
                        {if i < (output-header-not-required-params.size - 1) then
                            {out.write-one ','}
                        }
                        {out.write-one '\n'}
                    }
                    {out.write-one-string
                        "                \},\n"
                    }
                }
                || operations
                {out.write-one-string
                    "            \{splice self.operations[\"" & name & "\"]\}"}
             else
                || spec args
                {out.write-one-string
                    "            \{\{Array-of #XMLName\}"
                }
                || write out argument names
                {for param key i in in-params do
                    {if i > 0 then
                        {out.write-one ','}
                    }
                    {out.write-one-string "\n"}
                    {format out = out, "                %s",
                        {WSDLSchemaType.xml-name-to-curl-code param.xml-name}
                    }
                }
                {out.write-one-string
                    "\n" &
                    "            \},\n" &
                    "            \{\{Array-of SOAPObjectType\}"
                }
                
                || write out argument types
                {for param key i in in-params do
                    {if i > 0 then
                        {out.write-one ','}
                    }
                    {out.write-one-string "\n"}
                    {out.write-one-string
                        {param.type.soap-object-type-string
                            tab-level = 16,
                            expected-content-types = param.content-types
                        }
                    }
                }
                {out.write-one-string
                    "\n" &
                    "            \},\n" &
                    "            \{\{Array-of #XMLName\}"
                }
                || write out response names
                {for param key i in out-params do
                    {if i > 0 then
                        {out.write-one ','}
                    }
                    {out.write-one-string "\n"}
                    {format out = out, "                %s",
                        {WSDLSchemaType.xml-name-to-curl-code param.xml-name}
                    }
                }
                {out.write-one-string
                    "\n" &
                    "            \},\n" &
                    "            \{\{Array-of SOAPObjectType\}"
                }
                || write out response types
                {for param key i in out-params do
                    {if i > 0 then
                        {out.write-one ','}
                    }
                    {out.write-one-string "\n"}
                    {out.write-one-string
                        {param.type.soap-object-type-string
                            tab-level = 16,
                            expected-content-types = param.content-types
                        }
                    }
                }
                {out.write-one-string
                    "\n" &
                    "            \},\n"
                }
                || find WSDLBindingOperationMessage and get encoding from it.
                {if-non-null soap-body-encoding then
                    {format out = out,
                        "            \"%s\",\n",
                        soap-body-encoding
                    }
                 else
                    {out.write-one-string
                        "            null,\n"
                    }
                }
                {if-non-null soap-action = soap-op.soap-action then
                    {format out = out,
                        "            soap-action = \"%s\",\n",
                        soap-action
                    }
                }
                {if-non-null request-operation then
                    {format out = out,
                        "            request-operation = %s,\n",
                        {WSDLSchemaType.xml-name-to-curl-code
                            request-operation
                        }
                    }
                }
                {if response-operation != request-operation then
                    {format out = out,
                        "            response-operation = %s,\n",
                        {if-non-null response-operation then
                            {WSDLSchemaType.xml-name-to-curl-code
                                response-operation
                            }
                         else
                            "null"
                        }
                    }
                }
                {if soap-body-output-namespace != "" then
                    {format out = out,
                        "            default-namespace = \"%s\",\n",
                        soap-body-output-namespace
                    }
                }
                {format out = out,
                    "            rpc-style? = %s,\n",
                    {if soap-op.style == WSDLSOAPStyle.rpc then
                        "true"
                     else
                        "false"
                    }
                }
                {format out = out, 
                    "            write-type-attribute? = %s,\n",
                    {if input-soap-body != null and
                        input-soap-body.use == WSDLSOAPUse.encoded
                     then
                        "true"
                     else
                        "false"
                    }
                }
                {format out = out,
                    "            write-encoding-attribute? = %s",
                    {if input-soap-body != null and
                        input-soap-body.use == WSDLSOAPUse.encoded
                     then
                        "true"
                     else
                        "false"
                    }
                }
                {if binding.soap-version != SOAPVersion.soap-1-1 then
                    {format out = out,
                        ",\n            soap-version = SOAPVersion.%s",
                        binding.soap-version.name
                    }
                }

                || there isn't a way to configure MTOM settings
                || in the WSDL yet (we may be able to do this by using
                || the 'feature' element in WSDL2.0)
                || So now, commented out below until wsdk supports WSDL2.0.
||--                def support-req? =
||--                    {if-non-null input-m = binding-op.input then
||--                        (input-m.mtom-availability.value > 0)
||--                     else
||--                        false
||--                    }
||--                def support-res? =
||--                    {if-non-null output-m = binding-op.input then
||--                        (output-m.mtom-availability.value > 0)
||--                     else
||--                        false
||--                    }
||--                def range =
||--                    {if support-req? and support-res? then
||--                        SOAPMTOMSupportRange.both
||--                     elseif support-req? then
||--                        SOAPMTOMSupportRange.request
||--                     elseif support-res? then
||--                        SOAPMTOMSupportRange.response
||--                     else
||--                        SOAPMTOMSupportRange.none
||--                    }
||--                {if range != SOAPMTOMSupportRange.none then
||--                    {format out = out,
||--                        ",\n            mtom-support-range = %s",
||--                        range
||--                    }
||--                }
            }
            || %%% METHOD BODY CALL FINAL ARGS
            || ~~~~~~~~~~~~~~~~~~~~
            {if async-pass? then
                {out.write-one-string
                    ",\n" &
                    "            event-handler,\n" &
                    "            ..."
                }
            }
            {out.write-one '\n'}
            {if not def-pass? then
                {out.write-one-string
                    "        \}\n"
                }
            }
            || %%% METHOD BODY RETURN
            || ~~~~~~~~~~~~~~~~~~~~
            {if async-pass? or def-pass? then
                {out.write-one-string
                    "    \}\n"
                }
             else
                {out.write-one-string
                    "    \{return\n"
                }
                || handle returning values
                {for param key i in out-params do
                    {format out = out,
                        "        responses[%d] asa %s%s",
                        i,
                        {if param.nullable? then
                            "#"
                         else
                            ""
                        },
                        param.type.ref-name
                    }
                    {if i < ((out-params.size + output-header-required-params.size) - 1) then
                        {out.write-one-string ",\n"}
                    }
                }
                {for param key i in output-header-required-params do
                    {format out = out,
                        "        headers[%d] asa %s%s",
                        i,
                        {if param.nullable? then
                            "#"
                         else
                            ""
                        },
                        param.type.ref-name
                    }
                    {if i < (output-header-required-params.size - 1) then
                        {out.write-one-string ",\n"}
                    }
                }
                {if output-header-required-params.size +
                    output-header-not-required-params.size > 0
                 then
                    {if output-header-required-params.size + 
                        out-params.size > 0
                     then
                        {out.write-one-string ",\n"}
                    }
                    {out.write-one-string
                        "        headers,\n" &
                        "        header-roles,\n" &
                        "        header-must-understands"
                    }
                }

                || end of return
                {out.write-one-string "\n    \}\n"}
            }


            || end of body of method.
            {out.write-one-string "  \}\n\n"}

            || end of method-pass loop to write out
            || method sync and async.
        }

        || save summary of all of the types, so that we can
        || register any complicated ones on construction
        let note-types:{proc-type {WSDLParamArray}:void} =
            {proc {params:WSDLParamArray}:void
                {for param in params do
                    {if {types.get-if-exists param.type} == null then
                        {types.set param.type, param.element-name}
                    }
                }
            }
        {note-types in-params}
        {note-types out-params}
        {note-types input-header-required-params}
        {note-types input-header-not-required-params}
        {note-types output-header-required-params}
        {note-types output-header-not-required-params}
        || NOTE: should also collect and register fault types, probably
        || - but they are picked up anyway because 
        || - 'exclude-unreferenced-types? = true' 

    }
    || define operations
    {out.write-one-string
        "  \{method protected \{define-operations\}:void\n"
    }
    {for name in method-names do
        {out.write-one-string
            "     \{self.define-" & name & "\}\n"
        }}
    {out.write-one-string 
        "  \}\n\n"}

    || register types for SOAP conversion
    {out.write-one-string
        "  \{method public \{register-types\n" &
        "                 \}:(type-mapper:SOAPTypeMapper,\n" &
        "                    element-name-to-xml-type:SOAPElementNameToXMLTypeMapper,\n" &
        "                    xml-type-to-curl-type:SOAPXMLTypeToCurlTypeMapper,\n" &
        "                    curl-type-to-xml-type:SOAPCurlTypeToXMLTypeMapper,\n" &
        "                    xml-type-to-element-name:SOAPXMLTypeToElementNameMapper\n" &
        "                   )\n"
    }
    let made-mappers?:bool = false  
    
    || reachable types helper
    let tmp-types:{HashTable-of WSDLSchemaType, #XMLName} =
        {{HashTable-of WSDLSchemaType, #XMLName}}
    let concat-sub-types:{proc-type {{Iterator-of WSDLSchemaType}}:void} =
        {proc {new-types:{Iterator-of WSDLSchemaType}}:void
            {tmp-types.clear}
            {for type in new-types do
                {type.concat-sub-types tmp-types}
            }
            {for element-name key type in tmp-types do
                {types.set type, element-name}
            }
        }
    
    || include reachable types 
    || - starting from method parameters, collected above  
    {concat-sub-types {types.keys-to-Iterator}}
    
    || NOTE: default (as of WSDL 1.0.4) also includes unreachable types
    || - unreferenced types might be used at runtime by "xsi:type"
    let all-types?:bool = not exclude-unreferenced-types?
    {if all-types? then
        let more-types:{Array-of WSDLSchemaType} = 
            {{Array-of WSDLSchemaType}}
        {for type in self.schema.types do
            {if not {types.key-exists? type} then
                || exclude anonymous element types
                || - produced on behalf of request/response messages
                {if not {ignore-types.member? type} then
                    {more-types.append type}
                    set types[type] = null}
            }}
        {if not more-types.empty? then
            {concat-sub-types {more-types.to-Iterator}}}
    }            
    
    || assure repeatable order
    let sorted-types:{Array-of WSDLSchemaType} = {new {Array-of WSDLSchemaType}}
    {for key type in types do
        {sorted-types.append type}
    }
    {sorted-types.sort comparison-proc = 
        {proc {x:WSDLSchemaType, y:WSDLSchemaType}:bool
            {return {x.ref-name.compare y.ref-name} <= 0}
        }
    }
    || register types
    {for type key i in sorted-types do
        || Skip duplicates.
        {if i > 0 then
            def prev-type = sorted-types[i - 1]
            {if type.ref-name == prev-type.ref-name and
                type.xml-name == prev-type.xml-name and
                type.nullable? == prev-type.nullable? and
                type.multiple-reference == prev-type.multiple-reference and
                type.package-name == prev-type.package-name and
                type.marshaler-handled-element? ==
                    prev-type.marshaler-handled-element?
             then
                {continue}
            }
        }
        let element-name:#XMLName = types[type]
        let best-element-name:#XMLName =
            {if-non-null type-xml-name = type.xml-name then
                let (ben:XMLName, found?:bool) =
                    {self.type-to-element-name.get-if-exists type-xml-name}
                {if found? then
                    ben
                 else
                    element-name
                }
             else
                element-name
            }
        {if-non-null register-code =
            {type.register-type-code element-name = best-element-name}
         then
            {if not made-mappers? then
                {out.write-one-string
                    "    let constant type-mapper:DefaultSOAPTypeMapper =\n" &
                    "        \{DefaultSOAPTypeMapper\}\n" &
                    "    let constant element-name-to-xml-type:DefaultSOAPElementNameToXMLTypeMapper =\n" &
                    "        \{DefaultSOAPElementNameToXMLTypeMapper\}\n" &
                    "    let constant xml-type-to-curl-type:DefaultSOAPXMLTypeToCurlTypeMapper =\n" &
                    "        \{DefaultSOAPXMLTypeToCurlTypeMapper\}\n" &
                    "    let constant curl-type-to-xml-type:DefaultSOAPCurlTypeToXMLTypeMapper =\n" &
                    "        \{DefaultSOAPCurlTypeToXMLTypeMapper\}\n" &
                    "    let constant xml-type-to-element-name:DefaultSOAPXMLTypeToElementNameMapper =\n" &
                    "        \{DefaultSOAPXMLTypeToElementNameMapper\}\n"
                }
                set made-mappers? = true
            }
            {out.write-one-string register-code}
        }
    }
    || write out return statment.
    {out.write-one-string
        {if made-mappers? then
            "    \{return\n" &
            "        type-mapper,\n" &
            "        element-name-to-xml-type,\n" &
            "        xml-type-to-curl-type,\n" &
            "        curl-type-to-xml-type,\n" &
            "        xml-type-to-element-name\n" &
            "    \}\n"
         else
            "    \{return builtin-soap-type-mapper,\n" &
            "        builtin-soap-element-name-to-xml-type-mapper,\n" &
            "        builtin-soap-xml-type-to-curl-type-mapper,\n" &
            "        builtin-soap-curl-type-to-xml-type-mapper,\n" &
            "        builtin-soap-xml-type-to-element-name-mapper\n" &
            "    \}\n"
        }
    }
    {out.write-one-string "  \}\n\n"}

    || write out constructor that creates the SOAPHTTPRPCPostCaller
    let soap-url-string:String =
        {type-switch port.extensions[0] 
         case a:WSDLSOAPAddress do
            a.location
         else
            "UNKNOWN"
        }

    let service-location:String =
        {format "\{abs-url \"%s\"\}",
            {parse-url soap-url-string,                          
                relative-url = self.source-url
            }.name}

    {out.write-one-string
        "  \{constructor public\n" &
        "    \{default\n" & 
        "        service-location:Url =\n" &
        "            " & service-location & "\n" &
        "    \}\n" &
        || --------------------------------------------------
        "    \{construct-super service-location,\n" &
        "        generated-using-version = \"" & 
        wsdl-service-class-version & "\"\n" &
        "    \}\n" &
        "  \}\n"
    }
    
    || close class
    {out.write-one-string "\}\n\n"}
    {for xml-name key type in types do
        {all-types.insert type}
    }
  
    {return all-types}
    }

  {method package {dump-types  
                      out:TextOutputStream,
                      all-types:{Set-of WSDLSchemaType}
                  } :void   
    || assure repeatable order
    def sorted-types = {{Array-of WSDLSchemaType}}
    {for type in all-types do
        {sorted-types.append type}}
    {sorted-types.sort comparison-proc =
        {proc {x:WSDLSchemaType, y:WSDLSchemaType}:bool
            {return {x.ref-name.compare y.ref-name} <= 0}}}

    || needed imports
    def all-packages = {{Set-of String}}
    {for type in all-types do
        {if-non-null package = type.package-name then
            {all-packages.insert package}}}
    def sorted-packages = {StringArray}
    {for package in all-packages do
        {sorted-packages.append package}}
    {sorted-packages.sort}
    {if not sorted-packages.empty? then
        {out.write-one '\n'}
        {for package in sorted-packages do
            {format out = out,
                |"{import * from %s}"|, package}
            {out.write-one '\n'}}
        {out.write-one '\n'}
    }
    
    || type definitions
    {for type in sorted-types do
        {type.dump out}
    }
  }

  {method package {format-documentation 
                      out:TextOutputStream, 
                      ...:#WSDLDocumentedNode
                  }:void
    let n-doc:int = 0
    {for d in ... do
        {if-non-null d then
            {if d.documentation != "" then
                {if n-doc <= 0 then
                    || prelude
                    {out.write-one-string 
                        "\{doc-next \n" & 
                        "    \{details \n"}
                    {inc n-doc}
                }
                {if n-doc > 1 then
                    {out.write-one '\n'}}
                {format out = out,
                    "        %s\n",
                    {escapify-string d.documentation}}
            }
        }
    }
    {if n-doc > 0 then
        || postlude
        {out.write-one-string
            "    \}\n" & 
            "\}\n"}
    }
  }

}
